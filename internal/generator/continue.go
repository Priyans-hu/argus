package generator

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"github.com/Priyans-hu/argus/pkg/types"
)

// ContinueGenerator generates .continue/config.yaml files
type ContinueGenerator struct{}

// NewContinueGenerator creates a new Continue.dev generator
func NewContinueGenerator() *ContinueGenerator {
	return &ContinueGenerator{}
}

// Name returns the generator name
func (g *ContinueGenerator) Name() string {
	return "continue"
}

// OutputFile returns the output filename
func (g *ContinueGenerator) OutputFile() string {
	return ".continue/config.yaml"
}

// Generate creates the config.yaml content for Continue.dev
func (g *ContinueGenerator) Generate(analysis *types.Analysis) ([]byte, error) {
	var buf bytes.Buffer

	// Header
	buf.WriteString("# Continue.dev Configuration\n")
	buf.WriteString("# Generated by Argus - https://github.com/Priyans-hu/argus\n")
	buf.WriteString("# Documentation: https://docs.continue.dev/reference\n\n")

	// Basic config structure
	buf.WriteString("name: " + sanitizeYAMLString(analysis.ProjectName) + "\n")
	buf.WriteString("version: \"1.0.0\"\n")
	buf.WriteString("schema: v1\n\n")

	// Write rules section
	g.writeRules(&buf, analysis)

	// Write context providers
	g.writeContextProviders(&buf, analysis)

	// Write docs section if applicable
	g.writeDocs(&buf, analysis)

	return buf.Bytes(), nil
}

// writeRules writes coding rules based on detected conventions
func (g *ContinueGenerator) writeRules(buf *bytes.Buffer, analysis *types.Analysis) {
	buf.WriteString("# Rules are added to the system message for all requests\n")
	buf.WriteString("rules:\n")

	rules := []string{}

	// Add project context
	rules = append(rules, fmt.Sprintf("This is the %s project", analysis.ProjectName))

	// Add tech stack context
	if len(analysis.TechStack.Languages) > 0 {
		langs := make([]string, 0)
		for _, l := range analysis.TechStack.Languages {
			if l.Percentage > 5 {
				if l.Version != "" {
					langs = append(langs, fmt.Sprintf("%s %s", l.Name, l.Version))
				} else {
					langs = append(langs, l.Name)
				}
			}
		}
		if len(langs) > 0 {
			rules = append(rules, fmt.Sprintf("Primary technologies: %s", strings.Join(langs, ", ")))
		}
	}

	// Add framework context
	if len(analysis.TechStack.Frameworks) > 0 {
		fws := make([]string, 0)
		for _, fw := range analysis.TechStack.Frameworks {
			fws = append(fws, fw.Name)
		}
		rules = append(rules, fmt.Sprintf("Frameworks in use: %s", strings.Join(fws, ", ")))
	}

	// Add language-specific rules
	g.addLanguageRules(&rules, &analysis.TechStack)

	// Add detected conventions as rules
	g.addConventionRules(&rules, analysis.Conventions)

	// Add git conventions
	if analysis.GitConventions != nil {
		if analysis.GitConventions.CommitConvention != nil && analysis.GitConventions.CommitConvention.Style != "" {
			rules = append(rules, fmt.Sprintf("Use %s style for commit messages", analysis.GitConventions.CommitConvention.Style))
		}
		if analysis.GitConventions.BranchConvention != nil && analysis.GitConventions.BranchConvention.Format != "" {
			rules = append(rules, fmt.Sprintf("Branch naming: %s", analysis.GitConventions.BranchConvention.Format))
		}
	}

	// Write rules
	for _, rule := range rules {
		buf.WriteString("  - " + sanitizeYAMLString(rule) + "\n")
	}
	buf.WriteString("\n")
}

// addLanguageRules adds language-specific coding rules
func (g *ContinueGenerator) addLanguageRules(rules *[]string, stack *types.TechStack) {
	if len(stack.Languages) == 0 {
		return
	}

	primary := strings.ToLower(stack.Languages[0].Name)

	switch primary {
	case "go":
		*rules = append(*rules,
			"Use gofmt for formatting",
			"Handle all errors explicitly with if err != nil",
			"Write doc comments starting with the function name for exported functions",
			"Prefer composition over inheritance",
		)
	case "typescript", "javascript":
		*rules = append(*rules,
			"Use const for variables that won't be reassigned, let otherwise",
			"Prefer async/await over raw promises",
			"Use meaningful variable names",
		)
		// Check for React
		for _, fw := range stack.Frameworks {
			if strings.Contains(strings.ToLower(fw.Name), "react") {
				*rules = append(*rules,
					"Use functional components with hooks",
					"Extract reusable logic into custom hooks",
				)
				break
			}
		}
	case "python":
		*rules = append(*rules,
			"Follow PEP 8 style guide",
			"Use type hints for function parameters and return values",
			"Write docstrings for functions and classes",
		)
	case "rust":
		*rules = append(*rules,
			"Handle Result and Option types properly",
			"Avoid unwrap() in production code, use expect() or proper error handling",
			"Prefer borrowing over cloning when possible",
		)
	case "java":
		*rules = append(*rules,
			"Follow Java naming conventions",
			"Add Javadoc comments to public methods",
			"Prefer interfaces over concrete types",
		)
	case "ruby":
		*rules = append(*rules,
			"Follow Ruby style guide",
			"Use meaningful method names that read like English",
			"Prefer blocks over explicit procs",
		)
	case "c#":
		*rules = append(*rules,
			"Follow .NET naming conventions",
			"Use async/await for asynchronous operations",
			"Add XML documentation comments to public APIs",
		)
	}
}

// addConventionRules converts detected conventions to rules
func (g *ContinueGenerator) addConventionRules(rules *[]string, conventions []types.Convention) {
	// Group by category and pick most relevant
	categories := make(map[string][]types.Convention)
	for _, conv := range conventions {
		cat := conv.Category
		if cat == "" {
			cat = "general"
		}
		categories[cat] = append(categories[cat], conv)
	}

	// Add key conventions from each category
	for cat, convs := range categories {
		// Skip some categories that are too verbose
		if cat == "patterns" || cat == "detected-patterns" {
			continue
		}

		for i, conv := range convs {
			// Limit rules per category
			if i >= 2 {
				break
			}
			if conv.Description != "" && len(conv.Description) < 100 {
				*rules = append(*rules, conv.Description)
			}
		}
	}
}

// writeContextProviders writes context provider configuration
func (g *ContinueGenerator) writeContextProviders(buf *bytes.Buffer, analysis *types.Analysis) {
	buf.WriteString("# Context providers supply additional information to the model\n")
	buf.WriteString("context:\n")

	// Always include these basic providers
	buf.WriteString("  - provider: code\n")
	buf.WriteString("  - provider: diff\n")
	buf.WriteString("  - provider: terminal\n")
	buf.WriteString("  - provider: problems\n")
	buf.WriteString("  - provider: folder\n")

	// Add codebase provider for larger projects
	if len(analysis.Structure.Directories) > 5 {
		buf.WriteString("  - provider: codebase\n")
	}

	buf.WriteString("\n")
}

// writeDocs writes documentation indexing configuration
func (g *ContinueGenerator) writeDocs(buf *bytes.Buffer, analysis *types.Analysis) {
	// Check if there are frameworks that have documentation
	docsToIndex := []struct {
		title   string
		url     string
		favicon string
	}{}

	for _, fw := range analysis.TechStack.Frameworks {
		switch strings.ToLower(fw.Name) {
		case "react":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"React", "https://react.dev/reference", "https://react.dev/favicon.ico"})
		case "next.js", "nextjs":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"Next.js", "https://nextjs.org/docs", "https://nextjs.org/favicon.ico"})
		case "vue", "vue.js":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"Vue.js", "https://vuejs.org/guide", "https://vuejs.org/logo.svg"})
		case "express":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"Express", "https://expressjs.com/en/api.html", ""})
		case "fastapi":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"FastAPI", "https://fastapi.tiangolo.com/", ""})
		}
	}

	// Add language-specific docs
	if len(analysis.TechStack.Languages) > 0 {
		primary := strings.ToLower(analysis.TechStack.Languages[0].Name)
		switch primary {
		case "go":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"Go", "https://pkg.go.dev/std", ""})
		case "rust":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"Rust", "https://doc.rust-lang.org/std/", ""})
		case "python":
			docsToIndex = append(docsToIndex, struct {
				title   string
				url     string
				favicon string
			}{"Python", "https://docs.python.org/3/", ""})
		}
	}

	if len(docsToIndex) == 0 {
		return
	}

	buf.WriteString("# Documentation sites to index for @docs context\n")
	buf.WriteString("docs:\n")

	for _, doc := range docsToIndex {
		fmt.Fprintf(buf, "  - title: %s\n", doc.title)
		fmt.Fprintf(buf, "    startUrl: %s\n", doc.url)
		if doc.favicon != "" {
			fmt.Fprintf(buf, "    faviconUrl: %s\n", doc.favicon)
		}
	}
	buf.WriteString("\n")
}

// sanitizeYAMLString escapes special characters for YAML
func sanitizeYAMLString(s string) string {
	// If string contains special chars, quote it
	if strings.ContainsAny(s, ":{}[]&*#?|-<>=!%@`'\"\\") {
		// Escape double quotes and wrap in double quotes
		s = strings.ReplaceAll(s, "\\", "\\\\")
		s = strings.ReplaceAll(s, "\"", "\\\"")
		return "\"" + s + "\""
	}
	return s
}

// ContinueMultiFileGenerator generates multiple files for Continue.dev
type ContinueMultiFileGenerator struct{}

// NewContinueMultiFileGenerator creates a new multi-file Continue generator
func NewContinueMultiFileGenerator() *ContinueMultiFileGenerator {
	return &ContinueMultiFileGenerator{}
}

// Name returns the generator name
func (g *ContinueMultiFileGenerator) Name() string {
	return "continue-full"
}

// Generate creates multiple Continue.dev config files
func (g *ContinueMultiFileGenerator) Generate(analysis *types.Analysis) (map[string][]byte, error) {
	files := make(map[string][]byte)

	// Generate main config.yaml
	configGen := NewContinueGenerator()
	configContent, err := configGen.Generate(analysis)
	if err != nil {
		return nil, err
	}
	files[".continue/config.yaml"] = configContent

	// Generate rules file for more detailed rules
	rulesContent := g.generateRulesFile(analysis)
	if len(rulesContent) > 0 {
		files[".continue/rules/project.md"] = rulesContent
	}

	// Generate prompts file for custom slash commands
	promptsContent := g.generatePromptsFile(analysis)
	if len(promptsContent) > 0 {
		files[".continue/prompts/review.md"] = promptsContent
	}

	return files, nil
}

// generateRulesFile creates a detailed rules markdown file
func (g *ContinueMultiFileGenerator) generateRulesFile(analysis *types.Analysis) []byte {
	var buf bytes.Buffer

	buf.WriteString("# Project Rules for " + analysis.ProjectName + "\n\n")

	// Tech stack section
	buf.WriteString("## Tech Stack\n\n")
	if len(analysis.TechStack.Languages) > 0 {
		buf.WriteString("**Languages:**\n")
		for _, l := range analysis.TechStack.Languages {
			if l.Percentage > 5 {
				buf.WriteString(fmt.Sprintf("- %s", l.Name))
				if l.Version != "" {
					buf.WriteString(fmt.Sprintf(" %s", l.Version))
				}
				buf.WriteString(fmt.Sprintf(" (%.1f%%)\n", l.Percentage))
			}
		}
		buf.WriteString("\n")
	}

	if len(analysis.TechStack.Frameworks) > 0 {
		buf.WriteString("**Frameworks:**\n")
		for _, fw := range analysis.TechStack.Frameworks {
			buf.WriteString(fmt.Sprintf("- %s", fw.Name))
			if fw.Version != "" {
				buf.WriteString(fmt.Sprintf(" %s", fw.Version))
			}
			buf.WriteString("\n")
		}
		buf.WriteString("\n")
	}

	// Project structure
	if len(analysis.Structure.Directories) > 0 {
		buf.WriteString("## Project Structure\n\n")
		dirs := make([]types.Directory, len(analysis.Structure.Directories))
		copy(dirs, analysis.Structure.Directories)
		sort.Slice(dirs, func(i, j int) bool {
			return dirs[i].Path < dirs[j].Path
		})
		for _, dir := range dirs {
			if dir.Purpose != "" {
				buf.WriteString(fmt.Sprintf("- `%s/` - %s\n", dir.Path, dir.Purpose))
			}
		}
		buf.WriteString("\n")
	}

	// Conventions
	if len(analysis.Conventions) > 0 {
		buf.WriteString("## Coding Conventions\n\n")
		for _, conv := range analysis.Conventions {
			if conv.Description != "" {
				buf.WriteString(fmt.Sprintf("- %s\n", conv.Description))
			}
		}
		buf.WriteString("\n")
	}

	// Key files
	if len(analysis.KeyFiles) > 0 {
		buf.WriteString("## Key Files\n\n")
		for _, kf := range analysis.KeyFiles {
			buf.WriteString(fmt.Sprintf("- `%s`", kf.Path))
			if kf.Purpose != "" {
				buf.WriteString(fmt.Sprintf(" - %s", kf.Purpose))
			}
			buf.WriteString("\n")
		}
	}

	return buf.Bytes()
}

// generatePromptsFile creates a code review prompt file
func (g *ContinueMultiFileGenerator) generatePromptsFile(analysis *types.Analysis) []byte {
	var buf bytes.Buffer

	buf.WriteString("# Code Review Prompt\n\n")
	buf.WriteString("Review the selected code for:\n\n")
	buf.WriteString("1. **Correctness** - Does the code work as intended?\n")
	buf.WriteString("2. **Best Practices** - Does it follow project conventions?\n")
	buf.WriteString("3. **Performance** - Are there any obvious performance issues?\n")
	buf.WriteString("4. **Security** - Are there any security concerns?\n")
	buf.WriteString("5. **Maintainability** - Is the code easy to understand and modify?\n\n")

	// Add language-specific review points
	if len(analysis.TechStack.Languages) > 0 {
		primary := strings.ToLower(analysis.TechStack.Languages[0].Name)
		switch primary {
		case "go":
			buf.WriteString("## Go-specific checks:\n")
			buf.WriteString("- Error handling: Are all errors checked?\n")
			buf.WriteString("- Goroutine safety: Are there race conditions?\n")
			buf.WriteString("- Resource cleanup: Are defers used appropriately?\n")
		case "typescript", "javascript":
			buf.WriteString("## TypeScript/JavaScript checks:\n")
			buf.WriteString("- Type safety: Are types properly defined?\n")
			buf.WriteString("- Async handling: Are promises and async/await used correctly?\n")
			buf.WriteString("- Null checks: Are nullable values handled?\n")
		case "python":
			buf.WriteString("## Python checks:\n")
			buf.WriteString("- Type hints: Are type annotations present?\n")
			buf.WriteString("- Exception handling: Are exceptions caught appropriately?\n")
			buf.WriteString("- Resource management: Are context managers used?\n")
		}
		buf.WriteString("\n")
	}

	buf.WriteString("Provide specific, actionable feedback.\n")

	return buf.Bytes()
}
